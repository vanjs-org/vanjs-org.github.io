export const add=(t,...o)=>{for(const e of o)if(typeof e!=="object")t.appendChild(document.createTextNode(e));else if(Array.isArray(e))add(t,...e);else t.appendChild(e)};export const tag=(t,...o)=>{const[e,n]=typeof o[0]!=="object"||o[0]instanceof Node||Array.isArray(o[0])?[{},o]:[o[0],o.slice(1)];const r=document.createElement(t);for(const[t,o]of Object.entries(e))if(o)if(t.startsWith("on"))r[t]=o;else r.setAttribute(t,o);add(r,...n);return r};export const registerTags=(t,...o)=>{if(typeof t!=="object")return registerTags(window,t,...o);for(const e of o)t[e]=(...t)=>tag(e,...t);return t};export const state=t=>({val:t,t:[]});const strToTextDom=t=>typeof t!=="object"?document.createTextNode(t):t;export const bind=(t,o,e=(t=>strToTextDom(o(...t))))=>{if(!Array.isArray(t))return bind([t],o,e);const n=strToTextDom(o(...t.map((t=>t.val))));const r={o:t,i:n,p:e};for(const o of t)o.t.push(r);return n};export const setState=(t,o)=>{if(!Array.isArray(t))return setState([t],[o]);const e=new Set;for(let n=0;n<t.length;++n){const r=t[n];r.t=r.t.filter((t=>t.i.isConnected));if(o[n]!==r.val){r.u=r.val;r.val=o[n];for(const t of r.t)e.add(t)}}for(const t of e){const{i:o,o:e,p:n}=t;if(!o.isConnected)continue;const[r,s]=[e.map((t=>t.val)),e.map((t=>t.u))];const c=n(r,s,o);if(c!==o){o.replaceWith(c);t.i=c}}};