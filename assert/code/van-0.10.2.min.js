let t,e=Object,n=null,r={};export let empty=r;class l{constructor(t){this.t=t,this.l=[],this.o=[]}get val(){return this.t}set val(e){let r=this;e!==r.t&&(r.i?e===r.i&&(r.i=n,t.delete(r)):((e=>{t=(t??(setTimeout(s),new Set)).add(e)})(r),r.i=r.t),r.t=e,r.o.forEach((t=>t())))}}export let state=t=>new l(t);export let add=(t,...e)=>e.flat(1/0).forEach((e=>{return t.appendChild((n=e).nodeType?n:n instanceof l?bind(n,(t=>new Text(t))):new Text(n));var n}));export let tags=new Proxy(((t,...n)=>{let[r,...s]=n[0]?.constructor===e?n:[{},...n],o=document.createElement(t);return e.entries(r).forEach((([t,e])=>{t.startsWith("on")?o[t]=e:e instanceof l?bind(e,(e=>(o[t]=e,o))):o.setAttribute(t,e)})),add(o,...s),o}),{get:(t,e)=>t.bind(n,e)});let s=()=>{let e=[...t];t=n,new Set(e.flatMap((t=>t.l=t.l.filter((t=>t.u.isConnected))))).forEach((t=>{let{u:e,p:n,h:l}=t,s=l(...n.map((t=>t.t)),e,...n.map((t=>t.i)));s!==e&&(s!==r?e.replaceWith(s):e.remove(),t.u=s)})),e.forEach((t=>t.i=n))};export let bind=(...t)=>{let e=t.slice(0,-1),n=t[t.length-1],l=n(...e.map((t=>t.t)));if(l===r)return[];if(l.nodeType){let t={p:e,u:l,h:n};return e.forEach((e=>e.l.push(t))),l}let s=state(l),o=()=>s.val=n(...e.map((t=>t.t)),s.t,...e.map((t=>t.i)));return e.forEach((t=>t.o.push(o))),s};